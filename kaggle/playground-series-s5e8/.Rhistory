0.464,
0.540,
0.595,
0.432,
0.482
)
) %>%
rowwise() %>%
mutate(
std_mean = mean(c(std1, std2)),
b0 = b0,
tad = tad,
std_b_b0 = (std_mean / tad)
)
std_curve
four_pl <- function(params, x) {
A <- params[1] # max asymptote (b0)
B <- params[2] # hill slope
C <- params[3] # inflection point (e50)
D <- params[4] # min asymptote
y_predicted <- D + (A - D) / (1 + (x / C)^B)
return(y_predicted)
}
inverse_four_pl <- function(params, y) {
A <- params[1] # Max asymptote
B <- params[2] # Hill Slope
C <- params[3] # Inflection Point
D <- params[4] # Min asymptote
# The inverse 4PL equation
x_predicted <- C * (((A - D) / (y - D)) - 1)^(1 / B)
return(x_predicted)
}
sse_4pl <- function(params, x_obs, y_obs) {
# Get the predicted y-values from our 4PL model
y_predicted <- four_pl(params, x_obs)
# Calculate the sum of the squared differences (errors)
error <- sum((y_obs - y_predicted)^2)
return(error)
}
initial_params <- c(
A = max(std_curve$std_b_b0), # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = min(std_curve$std_b_b0) # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = concentration[concentration > 0],
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
dat %>%
ggplot(aes(
x, y
)) +
geom_line() +
geom_point(aes(x, std_curve$std_b_b0))
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
max(std_curve$std_b_b0)
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = min(std_curve$std_b_b0) # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = concentration[concentration > 0],
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = 0 # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = concentration[concentration > 0],
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = log(concentration[concentration > 0]),
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
exp(10)
exp(sample_concentrations)
pacman::p_load(
tidyverse,
ggplot2
)
nsb <- mean(c(0.195, 0.241))
tad <- mean(c(0.44, 0.482))
concentration <- c(600, 240, 96, 38.4, 15.4, 6.1, 0)
test_sample <- tibble(
OD1 = c(
0.180,
0.188,
0.228,
0.216,
0.225,
0.169,
0.210,
0.188,
0.254,
0.203,
0.245,
0.237,
0.380,
0.338
),
OD2 = c(
0.209,
0.171,
0.223,
0.226,
0.255,
0.293,
0.207,
0.224,
0.215,
0.203,
0.390,
0.312,
0.387,
0.264
)
) %>%
rowwise() %>%
mutate(
OD_mean = mean(c(OD1, OD2)),
b0 = tad,
OD = (OD_mean / tad)
) %>%
ungroup() %>%
mutate(
id = c(
"521",
"521",
"522",
"522",
"523",
"523",
"524",
"524",
"525",
"525",
"526",
"526",
"527",
"527"
),
cond = c(
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D"
)
)
test_sample
std_curve <- tibble(
std1 = c(
0.233,
0.271,
0.352,
0.352,
0.495,
0.472,
0.44
),
std2 = c(
0.478,
0.416,
0.464,
0.540,
0.595,
0.432,
0.482
)
) %>%
rowwise() %>%
mutate(
std_mean = mean(c(std1, std2)),
b0 = b0,
tad = tad,
std_b_b0 = (std_mean / tad)
)
std_curve
four_pl <- function(params, x) {
A <- params[1] # max asymptote (b0)
B <- params[2] # hill slope
C <- params[3] # inflection point (e50)
D <- params[4] # min asymptote
y_predicted <- D + (A - D) / (1 + (x / C)^B)
return(y_predicted)
}
inverse_four_pl <- function(params, y) {
A <- params[1] # Max asymptote
B <- params[2] # Hill Slope
C <- params[3] # Inflection Point
D <- params[4] # Min asymptote
# The inverse 4PL equation
x_predicted <- C * (((A - D) / (y - D)) - 1)^(1 / B)
return(x_predicted)
}
sse_4pl <- function(params, x_obs, y_obs) {
# Get the predicted y-values from our 4PL model
y_predicted <- four_pl(params, x_obs)
# Calculate the sum of the squared differences (errors)
error <- sum((y_obs - y_predicted)^2)
return(error)
}
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = 0 # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = log(concentration[concentration > 0]),
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
preds <- four_pl(optimized_params, seq(6.1, 600, 0.01))
dat <- tibble(
x = concentration[concentration > 0],
y = four_pl(optimized_params, concentration[concentration > 0])
)
dat
calculated_conc <- inverse_four_pl(optimized_params, std_curve$std_b_b0)
percent_recovery <- (calculated_conc / concentration) * 100
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
percent_recovery
pacman::p_load(
tidyverse,
ggplot2
)
nsb <- mean(c(0.195, 0.241))
tad <- mean(c(0.44, 0.482))
concentration <- c(600, 240, 96, 38.4, 15.4, 6.1, 0)
test_sample <- tibble(
OD1 = c(
0.180,
0.188,
0.228,
0.216,
0.225,
0.169,
0.210,
0.188,
0.254,
0.203,
0.245,
0.237,
0.380,
0.338
),
OD2 = c(
0.209,
0.171,
0.223,
0.226,
0.255,
0.293,
0.207,
0.224,
0.215,
0.203,
0.390,
0.312,
0.387,
0.264
)
) %>%
rowwise() %>%
mutate(
OD_mean = mean(c(OD1, OD2)),
b0 = tad,
OD = (OD_mean / tad)
) %>%
ungroup() %>%
mutate(
id = c(
"521",
"521",
"522",
"522",
"523",
"523",
"524",
"524",
"525",
"525",
"526",
"526",
"527",
"527"
),
cond = c(
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D",
"C",
"D"
)
)
test_sample
std_curve <- tibble(
std1 = c(
0.233,
0.271,
0.352,
0.352,
0.495,
0.472,
0.44
),
std2 = c(
0.478,
0.416,
0.464,
0.540,
0.595,
0.432,
0.482
)
) %>%
rowwise() %>%
mutate(
std_mean = mean(c(std1, std2)),
b0 = b0,
tad = tad,
std_b_b0 = (std_mean / tad)
)
std_curve
four_pl <- function(params, x) {
A <- params[1] # max asymptote (b0)
B <- params[2] # hill slope
C <- params[3] # inflection point (e50)
D <- params[4] # min asymptote
y_predicted <- D + (A - D) / (1 + (x / C)^B)
return(y_predicted)
}
inverse_four_pl <- function(params, y) {
A <- params[1] # Max asymptote
B <- params[2] # Hill Slope
C <- params[3] # Inflection Point
D <- params[4] # Min asymptote
# The inverse 4PL equation
x_predicted <- C * (((A - D) / (y - D)) - 1)^(1 / B)
return(x_predicted)
}
sse_4pl <- function(params, x_obs, y_obs) {
# Get the predicted y-values from our 4PL model
y_predicted <- four_pl(params, x_obs)
# Calculate the sum of the squared differences (errors)
error <- sum((y_obs - y_predicted)^2)
return(error)
}
initial_params <- c(
A = 1, # Guess A is the max observed OD
B = -1, # Guess B is -1 for a decreasing slope
C = median(concentration[concentration > 0]), # Guess C is the middle concentration
D = 0 # Guess D is the min observed OD
)
fit <- optim(
par = initial_params,
fn = sse_4pl,
x_obs = log(concentration[concentration > 0]),
y_obs = std_curve$std_b_b0[concentration > 0],
method = "BFGS"
)
optimized_params <- fit$par
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
sample_concentrations
ggplot(data = std_curve, aes(x = concentration, y = std_b_b0)) +
geom_point(color = "blue", size = 3, aes(y = std_b_b0)) +
stat_function(fun = function(x) four_pl(optimized_params, log(x)), color = "red", size = 1) +
scale_x_log10(breaks = c(1, 10, 100, 1000)) + # Use a logarithmic x-axis scale
labs(
title = "Corrected 4-Parameter Logistic Curve Fit",
x = "Concentration (pg/mL) [Log Scale]",
y = "Normalized OD (B/B₀)"
) +
theme_minimal()
sample_concentrations <- inverse_four_pl(optimized_params, test_sample$OD)
exp(sample_concentrations)
ggplot(data = std_curve, aes(x = concentration, y = std_b_b0)) +
geom_point(color = "blue", size = 3, aes(y = std_b_b0)) +
stat_function(fun = function(x) four_pl(optimized_params, (x)), color = "red", size = 1) +
scale_x_log10(breaks = c(1, 10, 100, 1000)) + # Use a logarithmic x-axis scale
labs(
title = "Corrected 4-Parameter Logistic Curve Fit",
x = "Concentration (pg/mL) [Log Scale]",
y = "Normalized OD (B/B₀)"
) +
theme_minimal()
pacman::p_load(
tidyverse
)
setwd(this.path::here())
# load data ----
train_data <- read_csv("train.csv")
train_data
colSums(is.na(train_data))
# repeated measures?
lenght(unique(train_data$id))
# repeated measures?
length(unique(train_data$id))
# repeated measures?
length(unique(train_data$id)) / length(train_data$id)
train_data
# age
plot(density(train_data$age))
# age x job
train_data %>%
select(age, job) %>%
ggplot(aes(
job, age
)) +
geom_boxplot()
# age x job
train_data %>%
select(age, job) %>%
ggplot(aes(
job, age
)) +
geom_boxplot(outlier.shape = NA) +
geom_point()
# age x job
train_data %>%
select(age, job) %>%
ggplot(aes(
job, age
)) +
geom_boxplot(outlier.shape = NA)
train_data
colnames(train_data)
